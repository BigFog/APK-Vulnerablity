<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>2.11.1 Broadcast——前言</title>
</head>
<body>
<div id="wmd-preview" class="wmd-preview"><div class="md-section-divider"></div><div class="md-section-divider"></div><h1 data-anchor-id="i3dr" id="2111-broadcast前言">2.11.1 Broadcast——前言</h1><p data-anchor-id="n78g">Broadcast Receiver是四大组件之一。分为广播发送者和广播接受者。系统会发出很多广播，比如时区的改变，电量过低，图片被选中等。应用也可生成广播，比如通知其他设备一些数据已经下载完成并且可以使用。 一个叫做MyBroadCastReceive r的广播接收器在AndroidManifest.xml文件中被注册。代码如下：</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="5iry"><ol class="linenums"><li class="L0"><code><span class="pln"> </span><span class="tag">&lt;receiver</span><span class="pln"> </span><span class="atn">android:name</span><span class="pun">=</span><span class="atv">"MyBroadCastReceiver"</span><span class="pln"> </span><span class="atn">android:export</span><span class="pun">=</span><span class="atv">"true"</span><span class="tag">&gt;</span></code></li><li class="L1"><code><span class="pln"> </span><span class="tag">&lt;intent-filter&gt;</span></code></li><li class="L2"><code><span class="pln">    </span><span class="tag">&lt;action</span><span class="pln"> </span><span class="atn">android:name</span><span class="pun">=</span><span class="atv">"MyBroadcast"</span><span class="tag">&gt;</span></code></li><li class="L3"><code><span class="pln">    </span><span class="tag">&lt;/action&gt;</span></code></li><li class="L4"><code><span class="pln"> </span><span class="tag">&lt;/intent-filter&gt;</span></code></li><li class="L5"><code><span class="pln"> </span><span class="tag">&lt;/receiver&gt;</span></code></li></ol></pre><p data-anchor-id="cjzy">Broadcast receiver 没有界面，但可以启动一个界面作为回应。或者使用Notification Manager提示用户，比如闪烁背光灯，震动设备，播放提示音等。 <br>
当发送一条广播时，系统会将发送的广播与系统中所有注册的符合条件的接受者的intent-filter进行匹配，若匹配成功，则执行相应接受者的onReceive函数。发送广播时如果处理不当，恶意应用便可以嗅探，拦截广播，致使如果接收广播时处理不当，便可以导致拒绝服务供给，伪造信息，越权操作。 <br>
<img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/190217/1.png" alt="https://raw.githubusercontent.com/BigFog/Photo_Save/master/190217/1.png" title=""></p><div class="md-section-divider"></div><h2 data-anchor-id="cf0c" id="安全风险">安全风险</h2><p data-anchor-id="q5kp">广播事件可以分为两种类型 <br>
<img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/190217/2.png" alt="https://raw.githubusercontent.com/BigFog/Photo_Save/master/190217/2.png"></p><ol data-anchor-id="9i6w">
<li>系统事件 <br>
系统事件是由系统发出的，比如启动完成，收到信息，电量过低等。比如当应用程序注册了短信接收事件，每收到一次短信就会唤醒broadcast receivers.</li>
<li>用户事件 <br>
除了系统生成的事件, 用户也可以注册一个自定义的应用程序广播事件接收器。 <br>
下面问题来了：</li>
</ol><p data-anchor-id="ekwn">1当我们的应用程序发送一个广播意图，是只有目标程序会收到，还是所有的程序会收到呢？ <br>
2 当我们注册了一个接收器，我们是只能从合法的广播来源接收程序还是也可以从恶意的程序那里接收到广播呢？ <br>
如果开发人员没有限制谁能广播谁不能广播的话，很明显答案是肯定的。如果接收器接收到了不信任源发来的广播，我们的应用程序会陷入危险。</p><div class="md-section-divider"></div><h2 data-anchor-id="s95v" id="动态广播">动态广播</h2><p data-anchor-id="pk60"><strong>注册接收类</strong>。该类继承BroadcastReceiver，并重写它的onReceiver（）方法。onReceiver（）就是程序接收到广播之后要进行的逻辑。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="r3mz"><ol class="linenums"><li class="L0"><code><span class="kwd">class</span><span class="pln"> </span><span class="typ">TestReceiver</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">BroadcastReceiver</span><span class="pun">{</span></code></li><li class="L1"><code><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> onReceiver</span><span class="pun">(</span><span class="typ">Context</span><span class="pln"> content</span><span class="pun">,</span><span class="typ">Intent</span><span class="pln"> intent</span><span class="pun">)</span></code></li><li class="L2"><code><span class="pun">{</span></code></li><li class="L3"><code><span class="pln">  </span><span class="typ">Log</span><span class="pun">.</span><span class="pln">d</span><span class="pun">(</span><span class="pln">tag</span><span class="pun">,</span><span class="str">"thsi is test!"</span><span class="pun">)</span></code></li><li class="L4"><code><span class="pun">}</span></code></li></ol></pre><p data-anchor-id="rdpx"><strong>动态注册</strong>（默认导出） <br>
注册方式简单明了，但缺点是必须是应用启动之后才能接收到广播，如果需要监听系统广播如开启广播，最好不要使用这种注册方式。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="urw0"><ol class="linenums"><li class="L0"><code><span class="typ">IntentFilter</span><span class="pln"> filter</span><span class="pun">=</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">IntenFilter</span><span class="pun">(</span><span class="str">"com.example.demo1.BROADCAST"</span><span class="pun">);</span></code></li><li class="L1"><code><span class="typ">TestReceiver</span><span class="pln"> receiver</span><span class="pun">=</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">TestReceiver</span><span class="pun">();</span></code></li><li class="L2"><code><span class="pln">registerReceiver</span><span class="pun">(</span><span class="pln">receiver</span><span class="pun">,</span><span class="pln">filter</span><span class="pun">);</span></code></li></ol></pre><p data-anchor-id="0hyn">首先创建爱一个IntentFilter,该对象的作用主要是说明接收的是哪一条广播。com.example.demo1.BROADCAST就是我们指明的一条广播动作，需要与广播发送时填入的动作相一致才能接收到广播。此时，广播接收者已经注册完毕。 <br>
<strong>按钮发送</strong></p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="9eqf"><ol class="linenums"><li class="L0"><code><span class="typ">Intent</span><span class="pln"> intent </span><span class="pun">=</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Intent</span><span class="pun">(</span><span class="str">"com.example.demo1.BROADCAST"</span><span class="pun">);</span></code></li><li class="L1"><code><span class="pln">sendBroadcast</span><span class="pun">(</span><span class="pln">intent</span><span class="pun">);</span></code></li></ol></pre><p data-anchor-id="18w0">这里Intent传入的参数需要与注册广播接收者IntentFilter里的参数相一致，并保证在整个应用程序中是唯一的。在发送广播时，可以在intent中传入数据，然后在OnReceive（）中获取以进行相应操作。 <br>
<strong>动态注册的广播需要解注册</strong> <br>
例如在activity中注册的广播接收者，那么可以在onDestor()方法中解注册。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="3np1"><ol class="linenums"><li class="L0"><code><span class="kwd">protected</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> onDestory</span><span class="pun">(){</span></code></li><li class="L1"><code><span class="kwd">super</span><span class="pun">.</span><span class="pln">onDestory</span><span class="pun">();</span></code></li><li class="L2"><code><span class="pln">unregisterRecceiver</span><span class="pun">(</span><span class="pln">receiver</span><span class="pun">);</span></code></li><li class="L3"><code><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><h2 data-anchor-id="eful" id="静态广播">静态广播</h2><p data-anchor-id="gmsx"><strong>静态注册</strong></p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="38ig"><ol class="linenums"><li class="L0"><code><span class="tag">&lt;receiver</span><span class="pln"> </span><span class="atn">android:name</span><span class="pun">=</span><span class="atv">".testReceiver"</span></code></li><li class="L1"><code><span class="atn">android:exported</span><span class="pun">=</span><span class="atv">"true"</span><span class="tag">&gt;</span></code></li><li class="L2"><code><span class="pln">    </span><span class="tag">&lt;intent-filter&gt;</span></code></li><li class="L3"><code><span class="pln">        </span><span class="tag">&lt;action</span><span class="pln"> </span><span class="atn">android:name</span><span class="pun">=</span><span class="atv">"com.example.demo1.BROADCAST"</span><span class="tag">&gt;</span></code></li><li class="L4"><code><span class="pln">     </span><span class="tag">&lt;/intent-filter&gt;</span></code></li><li class="L5"><code><span class="pln">    </span><span class="tag">&lt;/receiver&gt;</span></code></li></ol></pre><p data-anchor-id="u51z">发送广播</p></div>
</body>
</html>